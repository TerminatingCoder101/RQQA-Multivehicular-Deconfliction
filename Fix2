using OSQP
using Plots
using LinearAlgebra
using SparseArrays

function vehicle_dynamics(state, control)
    x, y, psi, v = state
    a, w = control

    x_dot = v * cos(psi)
    y_dot = v * sin(psi)
    psi_dot = w
    v_dot = a

    return [x_dot, y_dot, psi_dot, v_dot]
end

# Simulation parameters
const DT = 0.1      # Time step [s]
const T_MAX = 15.0    # Max simulation time [s]
const N_STEPS = Int(T_MAX / DT)

# Safety and physical parameters
const R_AGENT = 0.5 # Radius of the moving agent (Vehicle 1)
const D_SAFE = 2.0 # Desired clearance distance from the obstacle's radius
const D_MIN_TOTAL = D_SAFE + R_AGENT # The minimum allowed distance between vehicle centers

# Second-order CBF parameters, tuned to be more conservative
# to counteract discretization error at high speeds.
const K1 = 5.0
const K2 = 6.0

# Control limits
const V_MIN, V_MAX = 0.0, 2.0   # Min/max velocity [m/s]
const A_MIN, A_MAX = -1.0, 1.0  # Min/max acceleration [m/s^2]
const W_MIN, W_MAX = -pi, pi # Min/max angular velocity [rad/s]

# --- 2. Main Simulation Function ---

function run_simulation()
    # --- Initialization ---
    # Vehicle 1: Starts on the left, goal is on the right
    state1 = [-10.0, 0.1, 0.0, V_MAX] # Start with max velocity
    goal1 = [5.0, -2.5] # The fixed goal for Vehicle 1
    hist_state1 = [state1]
    hist_control1 = [[0.0, 0.0]]

    # Vehicle 2: The stationary "obstacle" is now offset to force a more complex maneuver
    state2 = [0.0, -0.5, 0.0, 0.0]
    hist_state2 = [state2]

    println("Starting simulation...")

    # --- Simulation Loop ---
    for i in 1:N_STEPS
        # --- Check if goal is reached ---
        if norm(state1[1:2] - goal1) < 0.2
            println("Goal reached at step $i. Stopping simulation.")
            break
        end

        # --- Nominal Controller ---
        # Vehicle 1's nominal controller always tries to drive it towards its fixed goal.
        error1 = goal1 - state1[1:2]
        angle_to_goal1 = atan(error1[2], error1[1])
        psi_error1 = atan(sin(angle_to_goal1 - state1[3]), cos(angle_to_goal1 - state1[3]))
        
        # Nominal control for [a, w]
        a_n1 = 0.5 * (V_MAX - state1[4]) # Try to maintain max speed
        w_n1 = 2.0 * psi_error1
        u_n1 = clamp.([a_n1, w_n1], [A_MIN, W_MIN], [A_MAX, W_MAX])

        # Vehicle 2's nominal control is to do nothing.
        u_n2 = [0.0, 0.0]

        # --- Second-Order CBF-QP Safety Filter ---
        p1 = state1[1:2]; psi1 = state1[3]; v1 = state1[4]
        p2 = state2[1:2]; psi2 = state2[3]; v2 = state2[4]
        
        delta_p = p1 - p2
        v1_vec = v1 * [cos(psi1), sin(psi1)]
        v2_vec = v2 * [cos(psi2), sin(psi2)]
        delta_v = v1_vec - v2_vec

        # The barrier function h now includes the agent's radius
        h = dot(delta_p, delta_p) - D_MIN_TOTAL^2
        h_dot = 2 * dot(delta_p, delta_v)

        # Constraint: h_ddot + k1*h_dot + k2*h >= 0
        Lfh = 2*dot(delta_v, delta_v) + K1*h_dot + K2*h
        
        g_a1 = 2 * dot(delta_p, [cos(psi1), sin(psi1)])
        g_w1 = 2 * v1 * dot(delta_p, [-sin(psi1), cos(psi1)])
        
        A_cbf = [g_a1 g_w1 0 0] 
        b_cbf_lower = -Lfh

        # QP formulation: min (u-u_n)'*H*(u-u_n)
        # We use a weighting matrix H to balance the cost of turning vs. braking.
        H = diagm([
            10.0,   # Adjusted cost for changing acceleration
            0.1,    # Low cost for changing angular velocity (encourages turning)
            1.0,    # Cost for vehicle 2 (doesn't matter as it's stationary)
            1.0
        ])
        
        P = sparse(H * 2.0)
        q = -2.0 * H * [u_n1; u_n2]
        
        # Constraints
        A = sparse([A_cbf; I])
        l = [b_cbf_lower; A_MIN; W_MIN; A_MIN; W_MIN]
        u = [Inf; A_MAX; W_MAX; A_MAX; W_MAX]
        
        # Create and solve the OSQP problem
        model = OSQP.Model()
        OSQP.setup!(model; P=P, q=q, A=A, l=l, u=u, verbose=false, eps_abs=1e-5, eps_rel=1e-5)
        results = OSQP.solve!(model)
        
        u_safe = [u_n1; u_n2] # Default to nominal if solver fails
        if results.info.status == :Solved
            u_safe = results.x
        else
            println("Warning: QP not solved at step $i. Using nominal control.")
        end

        u1_safe = u_safe[1:2]
        u2_safe = u_safe[3:4]

        # --- Update State ---
        state1 = state1 + vehicle_dynamics(state1, u1_safe) * DT
        state1[4] = clamp(state1[4], V_MIN, V_MAX) # Enforce velocity limits
        
        state2 = state2 + vehicle_dynamics(state2, u2_safe) * DT 
        
        # --- Store History ---
        push!(hist_state1, state1)
        push!(hist_state2, state2)
        push!(hist_control1, u1_safe)
    end

    println("Simulation finished.")
    return hist_state1, hist_state2, hist_control1
end

# --- 3. Plotting and Animation Function ---

function plot_and_animate(hist_state1, hist_state2, hist_control1)
    println("Generating plots and animation...")
    
    # --- Extract data for plots ---
    num_steps_run = length(hist_state1) - 1
    time_axis_states = 0:DT:(num_steps_run * DT)
    time_axis_controls = 0:DT:((num_steps_run-1) * DT)

    x1_hist = [s[1] for s in hist_state1]
    y1_hist = [s[2] for s in hist_state1]
    v1_hist = [s[4] for s in hist_state1]
    w1_hist = [c[2] for c in hist_control1[2:end]]
    
    x2_pos = hist_state2[1][1]
    y2_pos = hist_state2[1][2]
    goal_pos = [5.0, -2.5]
    theta = 0:0.1:(2*pi+0.1)

    # --- Generate Static Plots for Analysis ---
    p_traj = plot(x1_hist, y1_hist, label="V1 Path", lw=2, aspect_ratio=:equal,
                  xlabel="x [m]", ylabel="y [m]", title="Vehicle Trajectory")
    scatter!(p_traj, [x2_pos], [y2_pos], label="Obstacle", marker=:star5, markersize=8, color=:black)
    plot!(p_traj, x2_pos .+ D_MIN_TOTAL .* cos.(theta), y2_pos .+ D_MIN_TOTAL .* sin.(theta),
          seriestype=:shape, fillalpha=0.2, lw=0, label="Safety Zone", color=:red)
    scatter!(p_traj, [goal_pos[1]], [goal_pos[2]], label="Goal", marker=:xcross, markersize=8, color=:green)

    p_vel = plot(time_axis_states, v1_hist, label="V1 Velocity", lw=2,
                 xlabel="Time [s]", ylabel="Velocity [m/s]", title="Velocity Profile", legend=:bottomright)
    
    p_rot = plot(time_axis_controls, w1_hist, label="V1 ω", lw=2,
                 xlabel="Time [s]", ylabel="ω [rad/s]", title="Rotational Speed", legend=:bottomright)

    static_plot = plot(p_traj, p_vel, p_rot, layout=(1,3), size=(1800, 500))
    
    # Save the static plot to a file instead of displaying it
    plot_path = "cbf_analysis_plots.png"
    savefig(static_plot, plot_path)
    println("Analysis plots saved to $plot_path")


    # --- Generate Animation ---
    anim = @animate for i in 1:length(hist_state1)
        plot(x1_hist[1:i], y1_hist[1:i], 
             label="V1 Path", lw=2, aspect_ratio=:equal,
             xlims=(-11, 11), ylims=(-5, 5),
             xlabel="x [m]", ylabel="y [m]", title="Goal-Seeking with CBF Avoidance (Frame $i)")

        # Plot Vehicle 1's physical body
        plot!(x1_hist[i] .+ R_AGENT .* cos.(theta), y1_hist[i] .+ R_AGENT .* sin.(theta),
              seriestype=:shape, fillalpha=0.3, lw=0, label="Vehicle 1", color=:blue)

        # Plot stationary Vehicle 2 and the CORRECT safety zone
        scatter!([x2_pos], [y2_pos], label="Obstacle", marker=:star5, markersize=8, color=:black)
        plot!(x2_pos .+ D_MIN_TOTAL .* cos.(theta), y2_pos .+ D_MIN_TOTAL .* sin.(theta),
              seriestype=:shape, fillalpha=0.2, lw=0, label="Safety Zone", color=:red)
              
        # Plot the goal
        scatter!([goal_pos[1]], [goal_pos[2]], label="Goal", marker=:xcross, markersize=8, color=:green)
    end

    gif_path = "cbf_simulation.gif"
    gif(anim, gif_path, fps = 15)
    println("Animation saved to $gif_path")
end


# --- Run Simulation and Generate GIF ---
hist_state1, hist_state2, hist_control1 = run_simulation()
plot_and_animate(hist_state1, hist_state2, hist_control1)

println("Script finished. Press Enter to exit...")
readline()
