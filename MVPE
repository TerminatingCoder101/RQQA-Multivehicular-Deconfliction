#=
This script simulates a multi-agent pursuit-evasion scenario.
- One "Evader" (Vehicle 1): Tries to reach a fixed goal and uses a CBF
  to avoid all pursuers.
- Multiple "Pursuers": Faster than the evader, they do not have a CBF and
  will only ever move directly towards the evader.

This scenario demonstrates the CBF's ability to handle multiple dynamic
threats simultaneously.

This version saves all output to files (a .png for analysis plots and a
.gif for the animation) and does not open any interactive windows.

Dependencies:
- OSQP: A fast and reliable quadratic programming solver.
- Plots: For visualizing the results.
- LinearAlgebra: For vector and matrix operations.
- SparseArrays: For creating sparse matrices required by OSQP.

To run this, you need to have these packages installed in your Julia environment:
using Pkg
Pkg.add("OSQP")
Pkg.add("Plots")
Pkg.add("LinearAlgebra")
Pkg.add("SparseArrays")
=#

using OSQP
using Plots
using LinearAlgebra
using SparseArrays

# --- 1. System and Simulation Parameters ---

# A struct to hold vehicle information for cleaner code
mutable struct Vehicle
    state::Vector{Float64} # [x, y, psi, v]
    control::Vector{Float64} # [a, w]
    hist_state::Vector{Vector{Float64}}
    hist_control::Vector{Vector{Float64}}
    v_max::Float64
end

# Vehicle Dynamics Model
function vehicle_dynamics(state, control)
    x, y, psi, v = state
    a, w = control
    return [v * cos(psi), v * sin(psi), w, a]
end

# Simulation parameters
const DT = 0.1      # Time step [s]
const T_MAX = 20.0    # Max simulation time [s]
const N_STEPS = Int(T_MAX / DT)

# Safety and physical parameters
const R_AGENT = 0.5 # Radius of all agents
const D_MIN_TOTAL = 2 * R_AGENT + 0.5 # Min distance between centers

# Second-order CBF parameters
const K1 = 2.0
const K2 = 1.0
# Control limits
const A_MIN, A_MAX = -1.0, 1.0  # Min/max acceleration [m/s^2]
const W_MIN, W_MAX = -pi, pi # Min/max angular velocity [rad/s]

# --- 2. Main Simulation Function ---

function run_simulation()
    # --- Initialization ---
    # Vehicle 1 (Evader)
    evader = Vehicle(
        [-10.0, 0.0, 0.0, 2.0], # state
        [0.0, 0.0], # control
        [[-10.0, 0.0, 0.0, 2.0]], # hist_state
        [[0.0, 0.0]], # hist_control
        2.0 # v_max
    )
    goal = [10.0, 0.0]

    # Adding a third pursuer to create a more complex gauntlet.
    pursuers = [
        Vehicle([-2.0, 4.0, -pi/2, 2.2], [0,0], [[-2.0, 4.0, -pi/2, 2.2]], [[0,0]], 2.2),
        Vehicle([0.0, -5.0, pi/2, 2.2], [0,0], [[2.0, -4.0, pi/2, 2.2]], [[0,0]], 2.2),
    ]
    num_pursuers = length(pursuers)

    println("Starting simulation with 1 Evader and $num_pursuers Pursuers...")

    # --- Simulation Loop ---
    for i in 1:N_STEPS
        # --- Check if goal is reached ---
        if norm(evader.state[1:2] - goal) < 0.3
            println("Evader reached goal at step $i. Stopping simulation.")
            break
        end

        # --- Nominal Controller for Evader ---
        error1 = goal - evader.state[1:2]
        angle_to_goal1 = atan(error1[2], error1[1])
        psi_error1 = atan(sin(angle_to_goal1 - evader.state[3]), cos(angle_to_goal1 - evader.state[3]))
        a_n1 = 0.5 * (evader.v_max - evader.state[4])
        w_n1 = 2.0 * psi_error1
        u_n1 = clamp.([a_n1, w_n1], [A_MIN, W_MIN], [A_MAX, W_MAX])

        # --- Nominal Controllers for Pursuers (they don't use CBF) ---
        for p in pursuers
            goal_p = evader.state[1:2] # Pursuer's goal is always the evader
            error_p = goal_p - p.state[1:2]
            angle_to_goal_p = atan(error_p[2], error_p[1])
            psi_error_p = atan(sin(angle_to_goal_p - p.state[3]), cos(angle_to_goal_p - p.state[3]))
            a_np = 0.5 * (p.v_max - p.state[4])
            w_np = 2.0 * psi_error_p
            p.control = clamp.([a_np, w_np], [A_MIN, W_MIN], [A_MAX, W_MAX])
        end

        # --- CBF-QP Safety Filter for the EVADER ONLY ---
        # The QP will solve for the evader's control [a1, w1]
        # It needs one constraint for each pursuer.
        
        A_cbf = Matrix{Float64}(undef, num_pursuers, 2)
        b_cbf_lower = Vector{Float64}(undef, num_pursuers)

        for (j, p) in enumerate(pursuers)
            p1 = evader.state[1:2]; psi1 = evader.state[3]; v1 = evader.state[4]
            p2 = p.state[1:2]; psi2 = p.state[3]; v2 = p.state[4]
            
            delta_p = p1 - p2
            v1_vec = v1 * [cos(psi1), sin(psi1)]
            v2_vec = v2 * [cos(psi2), sin(psi2)]
            delta_v = v1_vec - v2_vec

            h = dot(delta_p, delta_p) - D_MIN_TOTAL^2
            h_dot = 2 * dot(delta_p, delta_v)
            
            # Since pursuers are uncontrolled from the evader's perspective,
            # their acceleration is part of the Lfh term.
            v2_dot_vec = p.control[1]*[cos(psi2),sin(psi2)] + p.control[2]*v2*[-sin(psi2),cos(psi2)]
            
            Lfh_j = 2*dot(delta_v,delta_v) - 2*dot(delta_p, v2_dot_vec) + K1*h_dot + K2*h
            
            g_a1 = 2 * dot(delta_p, [cos(psi1), sin(psi1)])
            g_w1 = 2 * v1 * dot(delta_p, [-sin(psi1), cos(psi1)])
            
            A_cbf[j, :] = [g_a1 g_w1]
            b_cbf_lower[j] = -Lfh_j
        end

        # QP formulation for the evader's control u1 = [a1, w1]
        H = diagm([20.0, 0.1])
        P = sparse(H * 2.0)
        q = -2.0 * H * u_n1
        
        A = sparse([A_cbf; I])
        l = [b_cbf_lower; A_MIN; W_MIN]
        u = [fill(Inf, num_pursuers); A_MAX; W_MAX]
        
        model = OSQP.Model()
        OSQP.setup!(model; P=P, q=q, A=A, l=l, u=u, verbose=false, eps_abs=1e-5, eps_rel=1e-5)
        results = OSQP.solve!(model)
        
        u1_safe = u_n1
        if results.info.status == :Solved
            u1_safe = results.x
        else
            println("Warning: QP not solved at step $i for evader. Using nominal control.")
        end
        evader.control = u1_safe

        # --- Update All States ---
        evader.state .+= vehicle_dynamics(evader.state, evader.control) * DT
        evader.state[4] = clamp(evader.state[4], 0.0, evader.v_max)
        
        for p in pursuers
            p.state .+= vehicle_dynamics(p.state, p.control) * DT
            p.state[4] = clamp(p.state[4], 0.0, p.v_max)
        end
        
        # --- Store History ---
        push!(evader.hist_state, evader.state)
        push!(evader.hist_control, evader.control)
        for p in pursuers
            push!(p.hist_state, p.state)
            push!(p.hist_control, p.control)
        end
    end

    println("Simulation finished.")
    return evader, pursuers, goal
end

# --- 3. Plotting and Animation Function ---

function plot_and_animate(evader, pursuers, goal)
    println("Generating plots and animation...")
    
    # --- Extract data ---
    num_steps_run = length(evader.hist_state) - 1
    time_axis_states = 0:DT:(num_steps_run * DT)
    time_axis_controls = 0:DT:((num_steps_run-1) * DT)
    theta = 0:0.1:(2*pi+0.1)

    # --- Generate Static Plots ---
    p_traj = plot(
        [s[1] for s in evader.hist_state], [s[2] for s in evader.hist_state],
        label="Evader Path", lw=2, aspect_ratio=:equal,
        xlabel="x [m]", ylabel="y [m]", title="Vehicle Trajectories"
    )
    for (i, p) in enumerate(pursuers)
        plot!(p_traj, [s[1] for s in p.hist_state], [s[2] for s in p.hist_state], label="Pursuer $i Path", lw=2)
    end
    scatter!(p_traj, [goal[1]], [goal[2]], label="Goal", marker=:xcross, markersize=8, color=:green)

    p_vel = plot(time_axis_states, [s[4] for s in evader.hist_state], label="Evader", lw=2, title="Velocity Profiles", xlabel="Time [s]")
    for (i, p) in enumerate(pursuers)
        plot!(p_vel, time_axis_states, [s[4] for s in p.hist_state], label="Pursuer $i", lw=2)
    end
    
    p_rot = plot(time_axis_controls, [c[2] for c in evader.hist_control[2:end]], label="Evader", lw=2, title="Rotational Speeds", xlabel="Time [s]")
     for (i, p) in enumerate(pursuers)
        plot!(p_rot, time_axis_controls, [c[2] for c in p.hist_control[2:end]], label="Pursuer $i", lw=2)
    end

    static_plot = plot(p_traj, p_vel, p_rot, layout=(1,3), size=(1800, 500))
    plot_path = "cbf_analysis_plots_multipursuit.png"
    savefig(static_plot, plot_path)
    println("Analysis plots saved to $plot_path")

    # --- Generate Animation ---
    anim = @animate for i in 1:length(evader.hist_state)
        plot(xlims=(-12, 12), ylims=(-10, 10), aspect_ratio=:equal,
             xlabel="x [m]", ylabel="y [m]", title="Multi-Pursuer Evasion (Frame $i)")

        # Plot Evader
        plot!([s[1] for s in evader.hist_state[1:i]], [s[2] for s in evader.hist_state[1:i]], label="Evader Path", lw=2, color=:blue)
        plot!([evader.hist_state[i][1]] .+ R_AGENT .* cos.(theta), [evader.hist_state[i][2]] .+ R_AGENT .* sin.(theta),
              seriestype=:shape, fillalpha=0.3, lw=0, label="Evader", color=:blue)
        
        # Plot Pursuers
        for (j, p) in enumerate(pursuers)
            plot!([s[1] for s in p.hist_state[1:i]], [s[2] for s in p.hist_state[1:i]], label="P$j Path", lw=2)
            plot!([p.hist_state[i][1]] .+ R_AGENT .* cos.(theta), [p.hist_state[i][2]] .+ R_AGENT .* sin.(theta),
                  seriestype=:shape, fillalpha=0.3, lw=0, label="P$j", color=:orange)
        end
              
        # Plot the goal
        scatter!([goal[1]], [goal[2]], label="Goal", marker=:xcross, markersize=8, color=:green)
    end

    gif_path = "cbf_simulation_multipursuit.gif"
    gif(anim, gif_path, fps = 15)
    println("Animation saved to $gif_path")
end


# --- Run Simulation and Generate GIF ---
evader, pursuers, goal = run_simulation()
plot_and_animate(evader, pursuers, goal)

println("Script finished. Press Enter to exit...")
readline()
